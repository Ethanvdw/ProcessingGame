/* autogenerated by Processing revision 1293 on 2024-04-06 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.stream.IntStream;
import java.util.stream.Collectors;
import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Optional;
import java.util.ArrayList;
import java.util.List;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class ProcessingGame extends PApplet {

/**
 * This is the main file of the Processing game.
 * It contains the setup and draw functions, as well as other helper functions
 * for initializing flocks, spawners, handling collisions, rendering, and checking game status.
 */









Crosshair crosshair;

Flock[] flocks;
final int N_FLOCKS = 5;
final int BOIDS = 10;
final int SPAWNERS = 10;
int delayFrames = 180;

ArrayList<BoidSpawner> boidSpawners = new ArrayList<>();

/**
 * The setup function is called once when the program starts.
 * It initializes the game window, crosshair, counters, flocks, and spawners.
 */
public void setup() {
    frameRate(80);
    /* size commented out by preprocessor */;
    surface.setTitle("Flock Off");
    crosshair = new Crosshair(); 
    setupCounter();
    initializeFlocks();
    initializeSpawners();
}

/**
 * The draw function is called continuously in a loop.
 * It updates the crosshair, renders spawners, runs flocks, handles boid collisions,
 * handles boid spawner collisions, renders counters, and checks the game status.
 */
public void draw() {
    background(0);
    crosshair.update();
    renderSpawners();
    runFlocks();
    handleBoidCollisions();
    handleBoidSpawnerCollisions();
    renderCounters();
    checkGameStatus();
}

/**
 * Renders all the spawners by calling the render function on each spawner.
 */
public void renderSpawners() {
    Arrays.stream(boidSpawners.toArray())
       .forEach(spawner -> ((BoidSpawner) spawner).render());
}

/**
 * Initializes the spawners by creating a specified number of boid spawners
 * with random positions and a given sprite image.
 */
public void initializeSpawners() {
    IntStream.range(0, SPAWNERS)
       .forEach(i -> boidSpawners.add(new BoidSpawner(random(width), random(height), "stars.png", 4, 1)));
}

/**
 * Handles collisions between boids and boid spawners.
 * For each flock, it checks if any boid collides with a spawner.
 * If a collision occurs, a new boid is spawned from the spawner and added to the flock.
 * The collided spawner is removed, and new spawners are created.
 */
public void handleBoidSpawnerCollisions() {
    for (Flock flock : flocks) {
        List<Boid> boidsCopy = new ArrayList<>(flock.getBoids());
        List<BoidSpawner> spawnersToRemove = new ArrayList<>();
        List<BoidSpawner> newSpawners = new ArrayList<>(); // Create a temporary list to hold new spawners
        
        boidsCopy.forEach(boid -> {
            boidSpawners.stream()
               .filter(spawner -> spawner.checkCollision(boid))
               .forEach(spawner -> {
                Boid newBoid = spawner.spawnBoid(boid.position.x, boid.position.y, flock);
                flock.addBoid(newBoid);
                spawnersToRemove.add(spawner);
                newSpawners.add(createNewSpawner()); // Add new spawners to the temporary list
            });
        });
        
        boidSpawners.removeAll(spawnersToRemove);
        boidSpawners.addAll(newSpawners); // Add new spawners to boidSpawners after the loop
    }
}

/**
 * Creates a new boid spawner with a random position and a given sprite image.
 * @return The newly created boid spawner.
 */
public BoidSpawner createNewSpawner() {
    return new BoidSpawner(random(width), random(height), "stars.png", 4, 1);
}

/**
 * Initializes the flocks by creating an array of flocks.
 * The first flock is the player flock, and the rest are enemy flocks.
 * Each flock is assigned a random color and a random sprite image.
 */
public void initializeFlocks() {
    flocks = new Flock[N_FLOCKS];
    
    flocks[0] = new Flock(generateRandomColor(), chooseRandomSprite("ships.png", 4, 4), BOIDS, true);
    
    IntStream.range(1, N_FLOCKS)
       .forEach(i -> flocks[i] = new Flock(generateRandomColor(), chooseRandomSprite("ships.png", 4, 4), BOIDS, false));
}

/**
 * Runs the update and render functions for each flock in the flocks array.
 */
public void runFlocks() {
    Flock[] flocksCopy = Arrays.copyOf(flocks, flocks.length);
    Arrays.stream(flocksCopy)
       .forEach(Flock ::  run);
}

/**
 * Handles collisions between boids within the flocks.
 * It checks for collisions only after a certain number of frames (delayFrames) have passed.
 * For each boid in the flocks, it checks for collisions with other boids in the flocks.
 */
public void handleBoidCollisions() {
    if (frameCount >= delayFrames) {
        List<Boid> boidsToCheck = Arrays.stream(flocks)
           .flatMap(flock -> flock.getBoids().stream())
           .collect(Collectors.toList());
        
        boidsToCheck.forEach(boid -> boid.checkFlockCollision(flocks));
    }
}

/**
 * Renders the counters for the player flock's boids and the enemy flocks' boids.
 * The counters display the number of boids in each flock.
 */
public void renderCounters() {
    renderCounter(flocks[0].getNumBoids(), 20, height - 20);
    renderCounter(getEnemyCount(flocks), width - 40, height - 20);
}

/**
 * Calculates and returns the total number of boids in the enemy flocks.
 * @param flocks The array of flocks.
 * @return The total number of boids in the enemy flocks.
 */
public int getEnemyCount(Flock[] flocks) {
    return Arrays.stream(flocks)
       .filter(flock -> !flock.isPlayerFlock())
       .mapToInt(Flock ::  getNumBoids)
       .sum();
}

/**
 * Checks the game status by checking the number of boids in the player flock and the enemy flocks.
 * If the player flock has no boids, it displays a "You lose!" message.
 * If all enemy flocks have no boids, it displays a "You win!" message.
 */
public void checkGameStatus() {
    if (flocks[0].getNumBoids() == 0) {
        displayMessage("You lose!", width / 2, height / 2);
        noLoop(); // Pause the sketch
    } else if (getEnemyCount(flocks) == 0) {
        displayMessage("You win!", width / 2, height / 2);
        noLoop(); // Pause the sketch
    }
}




/**
 * Represents a boid in a flocking simulation.
 */
class Boid {
    PImage boidImage;
    private PVector position;
    private PVector velocity;
    private PVector acceleration;
    private final float radius;
    private final float maxForce;
    private final float maxSpeed;
    private Flock flock;
    private int flockColor;
    
    /**
     * Constructs a new Boid object.
     *
     * @param x     The initial x-coordinate of the boid.
     * @param y     The initial y-coordinate of the boid.
     * @param flock The flock that the boid belongs to.
     */
    Boid(float x, float y, Flock flock) {
        acceleration = new PVector(0, 0);
        float angle = random(TWO_PI);
        velocity = new PVector(cos(angle), sin(angle));
        position = new PVector(x, y);
        radius = 4.0f;
        maxSpeed = 2.0f;
        maxForce = 0.03f;
        this.flock = flock;
        this.flockColor = flock.flockColor;
        this.boidImage = flock.boidImage;
    }
    
    /**
     * Runs the boid's behavior for each frame.
     *
     * @param boids The list of all boids in the simulation.
     */
    public void run(ArrayList<Boid> boids) {
        applyFlockingBehaviors(boids);
        updatePosition();
        wrapAroundBorders();
        render();
    }
    
    /**
     * Applies a force to the boid.
     *
     * @param force The force to be applied.
     */
    protected void applyForce(PVector force) {
        acceleration.add(force);
    }
    
    /**
     * Updates the position of the boid based on its velocity and acceleration.
     */
    protected void updatePosition() {
        velocity.add(acceleration);
        velocity.limit(maxSpeed);
        position.add(velocity);
        acceleration.mult(0);
    }
    
    /**
     * Calculates and applies the flocking forces to the boid.
     *
     * @param boids The list of all boids in the simulation.
     */
    private void applyFlockingBehaviors(ArrayList<Boid> boids) {
        PVector separationForce = getSeparationForce(boids);
        PVector alignmentForce = getAlignmentForce(boids);
        PVector cohesionForce = getCohesionForce(boids);
        
        // Adjust the force magnitudes as needed
        separationForce.mult(1.5f);
        alignmentForce.mult(1.0f);
        cohesionForce.mult(1.0f);
        
        applyForce(separationForce);
        applyForce(alignmentForce);
        applyForce(cohesionForce);
    }
    
    /**
     * Calculates the separation force to avoid crowding with other boids.
     *
     * @param boids The list of all boids in the simulation.
     * @return The separation force.
     */
    protected PVector getSeparationForce(ArrayList<Boid> boids) {
        float desiredSeparation = 25.0f;
        PVector steer = new PVector(0, 0);
        int count = 0;
        
        for (Boid other : boids) {
            float distance = PVector.dist(position, other.position);
            if (distance > 0 && distance < desiredSeparation) {
                PVector diff = PVector.sub(position, other.position);
                diff.normalize();
                diff.div(distance);
                steer.add(diff);
                count++;
            }
        }
        
        if (count > 0) {
            steer.div(count);
            steer.setMag(maxSpeed);
            steer.sub(velocity);
            steer.limit(maxForce);
        }
        
        return steer;
    }
    
    /**
     * Calculates the alignment force to match the velocity of nearby boids.
     *
     * @param boids The list of all boids in the simulation.
     * @return The alignment force.
     */
    protected PVector getAlignmentForce(ArrayList<Boid> boids) {
        float neighborDistance = 50.0f;
        PVector sum = new PVector(0, 0);
        int count = 0;
        
        for (Boid other : boids) {
            float distance = PVector.dist(position, other.position);
            if (distance > 0 && distance < neighborDistance) {
                sum.add(other.velocity);
                count++;
            }
        }
        
        if (count > 0) {
            sum.div(count);
            sum.setMag(maxSpeed);
            PVector steer = PVector.sub(sum, velocity);
            steer.limit(maxForce);
            return steer;
        } else {
            return new PVector(0, 0);
        }
    }
    
    /**
     * Calculates the cohesion force to move towards the center of nearby boids.
     *
     * @param boids The list of all boids in the simulation.
     * @return The cohesion force.
     */
    protected PVector getCohesionForce(ArrayList<Boid> boids) {
        float neighborDistance = 50.0f;
        PVector sum = new PVector(0, 0);
        int count = 0;
        
        for (Boid other : boids) {
            float distance = PVector.dist(position, other.position);
            if (distance > 0 && distance < neighborDistance) {
                sum.add(other.position);
                count++;
            }
        }
        
        if (count > 0) {
            sum.div(count);
            return seekTarget(sum);
        } else {
            return new PVector(0, 0);
        }
    }
    

    /**
     * Renders the boid on the screen.
     */
    protected void render() {
        float theta = velocity.heading2D() + radians(90);
        float scaleValue = 0.5f; // Change this value to scale the image
        imageMode(CENTER);
        tint(flockColor); // Apply the tint
        pushMatrix();
        translate(position.x, position.y);
        rotate(theta);
        scale(scaleValue);
        image(boidImage, 0, 0);
        popMatrix();
        noTint(); // Remove the tint for other drawings
    }

    
    /**
     * Wraps the boid around the borders of the screen.
     */
    protected void wrapAroundBorders() {
        if (position.x < - radius || position.x > width + radius) {
            position.x = (position.x + width) % width;
        }
        if (position.y < - radius || position.y > height + radius) {
            position.y = (position.y + height) % height;
        }
    }
    
    /**
     * Calculates the steering force to seek a target position.
     *
     * @param target The target position to seek.
     * @return The steering force.
     */
    protected PVector seekTarget(PVector target) {
        PVector desired = PVector.sub(target, position);
        desired.normalize();
        desired.mult(maxSpeed);
        PVector steer = PVector.sub(desired, velocity);
        steer.limit(maxForce);
        return steer;
    }
    
    /**
     * Checks for collision with other flocks and handles the collision behavior.
     *
     * @param flocks The array of all flocks in the simulation.
     */
    protected void checkFlockCollision(Flock[] flocks) {
        Flock currentFlock = this.flock;

        // Filters to find the first boid that is:
        // 1. In a different flock
        // 2. Within a certain distance
        // 3. In a flock with more boids
        Optional<Flock> otherFlockOpt = Arrays.stream(flocks)
            .filter(otherFlock -> otherFlock != currentFlock)
            .filter(otherFlock -> {
                return otherFlock.getBoids().stream().anyMatch(otherBoid -> {
                    float distance = PVector.dist(position, otherBoid.position);
                    return distance < 5.0f; // Adjust this value as needed
                });
            })
            .filter(otherFlock -> currentFlock.getNumBoids() < otherFlock.getNumBoids())
            .findFirst();

        if (otherFlockOpt.isPresent()) {
            Flock otherFlock = otherFlockOpt.get();
            currentFlock.getBoids().remove(this);

            if (otherFlock.isPlayerFlock) {
                otherFlock.addBoid(new PlayerControlledBoid(position.x, position.y, flocks[0]));
            } else {
                otherFlock.addBoid(new Boid(position.x, position.y, otherFlock));
            }

            this.flock = otherFlock;
            this.flockColor = otherFlock.flockColor;
        }
    }

}
PFont customFont;

public void setupCounter() {
    customFont = createFont("Kenney Space.ttf", 12);
}

public void renderCounter(int value, float x, float y) {
    textFont(customFont);
    textAlign(LEFT, CENTER);
    fill(255);
    text(value, x, y);
}

public void displayMessage(String message, float x, float y) {
    textFont(customFont);
    textAlign(CENTER, CENTER);
    fill(255);
    text(message, x, y);
}
class BoidSpawner {
    private PVector position;
    private static final float SPAWNER_SIZE = 25; // Fixed size for all spawners
    private PImage spriteSheet; // The sprite sheet
    private int spriteWidth, spriteHeight; // The size of each sprite in the sheet
    private int numFrames; // The number of frames in the sprite sheet
    private int currentFrame; // The current frame being displayed
    private static final int FRAME_DELAY = 14; // The number of draw calls to wait before changing frames
    private int frameCounter; // Counts the number of draw calls since the last frame change
    private int rows, cols; // The number of rows and columns in the sprite sheet

    BoidSpawner(float x, float y, String spriteSheetFilename, int rows, int cols) {
        this.position = new PVector(x, y);
        this.spriteSheet = loadImage(spriteSheetFilename);
        this.numFrames = rows * cols;
        this.rows = rows;
        this.cols = cols;
        this.spriteWidth = spriteSheet.width / cols;
        this.spriteHeight = spriteSheet.height / rows;
        this.currentFrame = 0;
        this.frameCounter = 0;
    }

    public void render() {
        int row = currentFrame / cols;
        int col = currentFrame % cols;
        int spriteX = col * spriteWidth;
        int spriteY = row * spriteHeight;
        image(spriteSheet, position.x, position.y, SPAWNER_SIZE, SPAWNER_SIZE, spriteX, spriteY, spriteX + spriteWidth, spriteY + spriteHeight);
        frameCounter++;
        if (frameCounter >= FRAME_DELAY) {
            currentFrame = (currentFrame + 1) % numFrames; // Cycle to the next frame
            frameCounter = 0;
        }
    }



        
        public boolean checkCollision(Boid boid) {
            float distance = PVector.dist(position, boid.position);
            return distance < SPAWNER_SIZE / 2 + boid.radius;
        }
        
        public Boid spawnBoid(float x, float y, Flock flock) {
            return new Boid(x, y, flock);
        }
        
        public void renderSpawners() {
            Arrays.stream(boidSpawners.toArray())
               .forEach(spawner -> ((BoidSpawner) spawner).render());
        }
    }
/**
 * The Crosshair class represents a crosshair object in a game.
 * It displays a crosshair image at the current mouse position.
 */
class Crosshair {
    PImage sprite;
    int x, y;
    
    /**
     * Constructs a new Crosshair object.
     * It loads the crosshair image, resizes it to 25x25 pixels, and hides the cursor.
     */
    Crosshair() {
        sprite = loadImage("crosshair.png");
        sprite.resize(25, 25);
        noCursor();
    }
    
    /**
     * Updates the position of the crosshair based on the current mouse position.
     * It displays the crosshair image at the updated position.
     */
    public void update() {
        x = mouseX;
        y = mouseY;
        image(sprite, x, y);
    }
}
/**
 * The Flock class represents a group of boids.
 * A flock has a color, an image for the boids, and a flag indicating whether it is a player-controlled flock.
 * It maintains a list of boids and provides methods to initialize and manipulate the flock.
 */



class Flock {
    private final List<Boid> boids;
    private final int flockColor;
    private final PImage boidImage;
    private final boolean isPlayerFlock;
    
    /**
     * Constructs a new Flock object with the specified color, boid image, number of boids, and player-controlled flag.
     * Initializes the list of boids and adds the specified number of boids to the flock.
     * @param flockColor the color of the flock
     * @param boidImage the image for the boids
     * @param numBoids the number of boids to initialize in the flock
     * @param isPlayerFlock a flag indicating whether the flock is player-controlled
     */
    Flock(int flockColor, PImage boidImage ,int numBoids, boolean isPlayerFlock) {
        boids = new ArrayList<>();
        this.flockColor = flockColor;
        this.boidImage = boidImage;
        this.isPlayerFlock = isPlayerFlock;
        initializeBoids(numBoids, isPlayerFlock);
    }
    
    /**
     * Initializes the flock with the specified number of boids.
     * The boids are initially positioned at the center of the screen.
     * If the flock is player-controlled, it creates PlayerControlledBoid objects, otherwise it creates Boid objects.
     * @param numBoids the number of boids to initialize in the flock
     * @param isPlayerControlled a flag indicating whether the boids are player-controlled
     */
    public void initializeBoids(int numBoids, boolean isPlayerControlled) {
        int boidX = width / 2;
        int boidY = height / 2;
        IntStream.range(0, numBoids).forEach(i -> {
            Boid boid = isPlayerControlled ? new PlayerControlledBoid(boidX, boidY, this) : new Boid(boidX, boidY, this);
            boids.add(boid);
        });
    }
    
    /**
     * Runs the flock by updating and rendering each boid in the flock.
     */
    public void run() {
        ArrayList<Boid> boidsArrayList = new ArrayList<>(boids);
        boids.forEach(boid -> boid.run(boidsArrayList));
    }
    
    /**
     * Adds a boid to the flock.
     * @param boid the boid to add
     */
    public void addBoid(Boid boid) {
        boids.add(boid);
    }
    
    /**
     * Returns the list of boids in the flock.
     * @return the list of boids
     */
    public List<Boid> getBoids() {
        return boids;
    }
    
    /**
     * Returns the number of boids in the flock.
     * @return the number of boids
     */
    public int getNumBoids() {
        return boids.size();
    }
    
    /**
     * Checks if the flock is player-controlled.
     * @return true if the flock is player-controlled, false otherwise
     */
    public boolean isPlayerFlock() {
        return isPlayerFlock;
    }
}
/**
 * The PlayerControlledBoid class represents a boid that is controlled by the player.
 * It extends the Boid class and overrides the run method to implement player-controlled behavior.
 */
class PlayerControlledBoid extends Boid {
    
    /**
     * Constructs a new PlayerControlledBoid object with the specified position and flock.
     * 
     * @param x     The x-coordinate of the boid's position.
     * @param y     The y-coordinate of the boid's position.
     * @param flock The flock that the boid belongs to.
     */
    PlayerControlledBoid(float x, float y, Flock flock) {
        super(x, y, flock);
    }
    
    /**
     * Overrides the run method of the Boid class to implement player-controlled behavior.
     * It calculates the steering force based on the mouse position and applies it to the boid.
     * It also updates the position, wraps around the borders, and renders the boid.
     * 
     * @param boids The list of all boids in the flock.
     */
    @Override public 
    void run(ArrayList<Boid> boids) {
        PVector mousePosition = getMousePosition();
        PVector steeringForce = getSteeringForce(boids, mousePosition);
        applyForce(steeringForce);
        updatePosition();
        wrapAroundBorders();
        render();
    }
    
    /**
     * Returns the current mouse position as a PVector object.
     * If the mouse is not on the screen, it returns null.
     * 
     * @return The current mouse position as a PVector object, or null if the mouse is not on the screen.
     */
    private PVector getMousePosition() {
        if (isMouseOnScreen()) {
            return new PVector(mouseX, mouseY);
        }
        return null;
    }
    
    /**
     * Checks if the mouse is on the screen.
     * 
     * @return true if the mouse is on the screen, false otherwise.
     */
    private boolean isMouseOnScreen() {
        return mouseX >= 0 && mouseX < width && mouseY >= 0 && mouseY < height;
    }
    
    /**
     * Calculates the steering force for the boid based on the mouse position.
     * If the mouse is on the screen, it seeks the mouse position.
     * Otherwise, it gets the flocking force from the other boids.
     * It also adds separation force to the steering force.
     * 
     * @param boids         The list of all boids in the flock.
     * @param mousePosition The current mouse position.
     * @return The steering force for the boid.
     */
    private PVector getSteeringForce(ArrayList<Boid> boids, PVector mousePosition) {
        PVector steeringForce = new PVector(0, 0);
        
        if (mousePosition != null) {
            steeringForce = seekTarget(mousePosition);
        } else {
            steeringForce = getFlockingForce(boids);
        }
        
        PVector separationForce = getSeparationForce(boids);
        separationForce.mult(1.5f);
        steeringForce.add(separationForce);
        
        return steeringForce;
    }
    
    /**
     * Calculates the flocking force for the boid based on the other boids in the flock.
     * It gets the alignment force and cohesion force from the other boids.
     * It also adds the alignment force and cohesion force to the flocking force.
     * 
     * @param boids The list of all boids in the flock.
     * @return The flocking force for the boid.
     */
    private PVector getFlockingForce(ArrayList<Boid> boids) {
        PVector alignmentForce = getAlignmentForce(boids);
        PVector cohesionForce = getCohesionForce(boids);
        
        alignmentForce.mult(1.0f);
        cohesionForce.mult(1.0f);
        
        PVector flockingForce = new PVector();
        flockingForce.add(alignmentForce);
        flockingForce.add(cohesionForce);
        
        return flockingForce;
    }
}
/**
 * Generates a random color.
 * 
 * @return The randomly generated color.
 */
public int generateRandomColor() {
    return color(random(255), random(255), random(255));
}

/**
 * Sets up the cursor to be hidden.
 */
public void cursorSetup() {
    noCursor();
}

/**
 * Chooses a random sprite from a sprite sheet.
 * 
 * @param filename The filename of the sprite sheet.
 * @param rows The number of rows in the sprite sheet.
 * @param cols The number of columns in the sprite sheet.
 * @return The randomly chosen sprite.
 */
public PImage chooseRandomSprite(String filename, int rows, int cols) {
    PImage spriteSheet = loadImage(filename);
    int totalSprites = rows * cols;
    int spriteSize = spriteSheet.width / cols;
    int spriteIndex = PApplet.parseInt(random(0, totalSprites));
    int row = spriteIndex / cols;
    int col = spriteIndex % cols;
    PImage sprite = spriteSheet.get(col * spriteSize, row * spriteSize, spriteSize, spriteSize);
    return sprite;
}


  public void settings() { size(800, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "ProcessingGame" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
