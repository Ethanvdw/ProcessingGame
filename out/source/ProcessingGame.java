/* autogenerated by Processing revision 1293 on 2024-03-31 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Arrays;
import java.util.stream.IntStream;
import java.util.stream.Collectors;
import java.util.Arrays;
import java.util.Optional;
import java.util.ArrayList;
import java.util.List;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class ProcessingGame extends PApplet {





Flock[] flocks;
final int N_FLOCKS = 5;
final int BOIDS = 10;
int delayFrames = 180;

public void setup() {
    frameRate(80);
    /* size commented out by preprocessor */;
    surface.setTitle("Flock Off");
    setupCounter();
    initializeFlocks();
}

public void initializeFlocks() {
    flocks = new Flock[N_FLOCKS];

    // Create the player's flock
    flocks[0] = new Flock(generateRandomColor(), BOIDS + 1, true);

    // Create the remaining flocks
    IntStream.range(1, N_FLOCKS)
             .forEach(i -> flocks[i] = new Flock(generateRandomColor(), BOIDS, false));

}

public void draw() {
    background(50);
    Arrays.stream(flocks).forEach(Flock::run);

    if (frameCount >= delayFrames) {
        List<Boid> boidsToCheck = Arrays.stream(flocks)
                                        .flatMap(flock -> flock.getBoids().stream())
                                        .collect(Collectors.toList());
        boidsToCheck.forEach(boid -> boid.checkFlockCollision(flocks));
    }

    renderCounter(flocks[0].getNumBoids(), 20, height - 20);
    renderCounter(GetEnemyCount(flocks), width - 40, height - 20);
}

public int GetEnemyCount(Flock[] flocks) {
    return Arrays.stream(flocks)
                 .filter(flock -> !flock.isPlayerFlock())
                 .mapToInt(Flock::getNumBoids)
                 .sum();
}




/**
* Represents a boid in a flocking simulation.
*/
class Boid {
    private PVector position;
    protected PVector velocity;
    protected PVector acceleration;
    private final float radius;
    private final float maxForce;
    private final float maxSpeed;
    Flock flock;
    private int flockColor;
    
    /**
    * Constructs a new Boid object.
    * 
    * @param x     The initial x-coordinate of the boid.
    * @param y     The initial y-coordinate of the boid.
    * @param flock The flock that the boid belongs to.
    */
    Boid(float x, float y, Flock flock) {
        acceleration = new PVector(0, 0);
        float angle = random(TWO_PI);
        velocity = new PVector(cos(angle), sin(angle));
        position = new PVector(x, y);
        radius = 2.0f;
        maxSpeed = 2.0f;
        maxForce = 0.03f;
        this.flock = flock;
        this.flockColor = flock.flockColor;
    }
    
    /**
    * Runs the boid's behavior for each frame.
    * 
    * @param boids The list of all boids in the simulation.
    */
    public void run(ArrayList<Boid> boids) {
        flock(boids);
        updatePosition();
        wrapAroundBorders();
        render();
    }
    
    /**
    * Applies a force to the boid.
    * 
    * @param force The force to be applied.
    */
    protected void applyForce(PVector force) {
        acceleration.add(force);
    }
    
    /**
    * Updates the position of the boid based on its velocity and acceleration.
    */
    protected void updatePosition() {
        velocity.add(acceleration);
        velocity.limit(maxSpeed);
        position.add(velocity);
        acceleration.mult(0);
    }
    
    /**
    * Calculates and applies the flocking forces to the boid.
    * 
    * @param boids The list of all boids in the simulation.
    */
    private void flock(ArrayList<Boid> boids) {
        PVector separationForce = getSeparationForce(boids);
        PVector alignmentForce = getAlignmentForce(boids);
        PVector cohesionForce = getCohesionForce(boids);
        separationForce.mult(1.5f);
        alignmentForce.mult(1.0f);
        cohesionForce.mult(1.0f);
        applyForce(separationForce);
        applyForce(alignmentForce);
        applyForce(cohesionForce);
    }
    
    /**
    * Calculates the separation force to avoid crowding with other boids.
    * 
    * @param boids The list of all boids in the simulation.
    * @return The separation force.
    */
    protected PVector getSeparationForce(ArrayList<Boid> boids) {
        float desiredSeparation = 25.0f;
        PVector steer = new PVector(0, 0);
        int count = 0;
        for (Boid other : boids) {
            float distance = PVector.dist(position, other.position);
            if (distance > 0 && distance < desiredSeparation) {
                PVector diff = PVector.sub(position, other.position);
                diff.normalize();
                diff.div(distance);
                steer.add(diff);
                count++;
            }
        }
        if (count > 0) {
            steer.div(count);
            steer.setMag(maxSpeed);
            steer.sub(velocity);
            steer.limit(maxForce);
        }
        return steer;
    }
    
    /**
    * Calculates the alignment force to match the velocity of nearby boids.
    * 
    * @param boids The list of all boids in the simulation.
    * @return The alignment force.
    */
    protected PVector getAlignmentForce(ArrayList<Boid> boids) {
        float neighborDistance = 50.0f;
        PVector sum = new PVector(0, 0);
        int count = 0;
        for (Boid other : boids) {
            float distance = PVector.dist(position, other.position);
            if (distance > 0 && distance < neighborDistance) {
                sum.add(other.velocity);
                count++;
            }
        }
        if (count > 0) {
            sum.div(count);
            sum.setMag(maxSpeed);
            PVector steer = PVector.sub(sum, velocity);
            steer.limit(maxForce);
            return steer;
        } else {
            return new PVector(0, 0);
        }
    }
    
    /**
    * Calculates the cohesion force to move towards the center of nearby boids.
    * 
    * @param boids The list of all boids in the simulation.
    * @return The cohesion force.
    */
    protected PVector getCohesionForce(ArrayList<Boid> boids) {
        float neighborDistance = 50.0f;
        PVector sum = new PVector(0, 0);
        int count = 0;
        for (Boid other : boids) {
            float distance = PVector.dist(position, other.position);
            if (distance > 0 && distance < neighborDistance) {
                sum.add(other.position);
                count++;
            }
        }
        if (count > 0) {
            sum.div(count);
            return seekTarget(sum);
        } else {
            return new PVector(0, 0);
        }
    }
    
    /**
    * Renders the boid on the screen.
    */
    protected void render() {
        float theta = velocity.heading2D() + radians(90);
        fill(flockColor);
        stroke(255);
        pushMatrix();
        translate(position.x, position.y);
        rotate(theta);
        renderBoidShape();
        popMatrix();
    }
    
    /**
    * Renders the shape of the boid.
    */
    private void renderBoidShape() {
        beginShape();
        vertex(0, -radius * 2);
        bezierVertex( - radius, -radius, -radius * 2, radius, 0, radius * 2);
        bezierVertex(radius * 2, radius, radius, -radius, 0, -radius * 2);
        endShape(CLOSE);
    }
        
        /**
        * Wraps the boid around the borders of the screen.
        */
        protected void wrapAroundBorders() {
            if (position.x < - radius || position.x > width + radius) {
                position.x = (position.x + width) % width;
            }
            if (position.y < - radius || position.y > height + radius) {
                position.y = (position.y + height) % height;
            }
        }
        
        /**
        * Calculates the steering force to seek a target position.
        * 
        * @param target The target position to seek.
        * @return The steering force.
        */
        protected PVector seekTarget(PVector target) {
            PVector desired = PVector.sub(target, position);
            desired.normalize();
            desired.mult(maxSpeed);
            PVector steer = PVector.sub(desired, velocity);
            steer.limit(maxForce);
            return steer;
        }
        
        /**
        * Checks for collision with other flocks and handles the collision behavior.
        * 
        * @param flocks The array of all flocks in the simulation.
        */
        
        protected void checkFlockCollision(Flock[] flocks) {
            Flock currentFlock = this.flock;
            
            Optional<Flock> otherFlockOpt = Arrays.stream(flocks)
               .filter(otherFlock -> otherFlock != currentFlock)
               .filter(otherFlock -> {
                PVector otherFlockCenter = getLargestFlockCenter(otherFlock);
                float distance = PVector.dist(position, otherFlockCenter);
                return distance < 50.0f; // Adjust this value as needed
            })
           .filter(otherFlock -> currentFlock.getNumBoids() < otherFlock.getNumBoids())
               .findFirst();
            
            if (otherFlockOpt.isPresent()) {
                Flock otherFlock = otherFlockOpt.get();
                currentFlock.getBoids().remove(this);
                otherFlock.addBoid((otherFlock == flocks[0]) ? new PlayerControlledBoid(position.x, position.y, flocks[0]) : this);
                
                this.flock = otherFlock;
                this.flockColor = otherFlock.flockColor;
            }
        }
        /**
        * Calculates the center position of a flock.
        * 
        * @param flock The flock to calculate the center position for.
        * @return The center position of the flock.
        */
        private PVector getLargestFlockCenter(Flock flock) {
            PVector center = new PVector(0, 0);
            List<Boid> boids = flock.getBoids();
            for (Boid boid : boids) {
                center.add(boid.position);
            }
            center.div(boids.size());
            return center;
        }
    }
PFont customFont;

public void setupCounter() {
    customFont = createFont("Kenney Bold.ttf", 12);
}

public void renderCounter(int value, float x, float y) {
    textFont(customFont);
    textAlign(LEFT, CENTER);
    fill(255);
    text(value, x, y);
}



class Flock {
    private final List<Boid> boids;
    private final int flockColor;
    private final boolean isPlayerFlock;
    
    Flock(int flockColor, int numBoids, boolean isPlayerFlock) {
        boids = new ArrayList<>();
        this.flockColor = flockColor;
        this.isPlayerFlock = isPlayerFlock;
        initializeBoids(numBoids, isPlayerFlock);
    }
    
    public void initializeBoids(int numBoids, boolean isPlayerControlled) {
        int boidX = width / 2;
        int boidY = height / 2;
        IntStream.range(0, numBoids).forEach(i -> {
            Boid boid = isPlayerControlled ? new PlayerControlledBoid(boidX, boidY, this) : new Boid(boidX, boidY, this);
            boids.add(boid);
        });
    }
    
    public void run() {
        ArrayList<Boid> boidsArrayList = new ArrayList<>(boids);
        boids.forEach(boid -> boid.run(boidsArrayList));
    }
    
    public void addBoid(Boid boid) {
        boids.add(boid);
    }
    
    public List<Boid> getBoids() {
        return boids;
    }
    
    public int getNumBoids() {
        return boids.size();
    }
    
    public boolean isPlayerFlock() {
        return isPlayerFlock;
    }
}
class PlayerControlledBoid extends Boid {
    PlayerControlledBoid(float x, float y, Flock flock) {
        super(x, y, flock);
    }
    
    @Override public 
    void run(ArrayList<Boid> boids) {
        PVector mousePosition = getMousePosition();
        PVector steeringForce = getSteeringForce(boids, mousePosition);
        applyForce(steeringForce); 
        updatePosition();
        wrapAroundBorders();
        render();
    }
    
    private PVector getMousePosition() {
        if (isMouseOnScreen()) {
            return new PVector(mouseX, mouseY);
        }
        return null;
    }
    
    private boolean isMouseOnScreen() {
        return mouseX >= 0 && mouseX < width && mouseY >= 0 && mouseY < height;
    }
    
    private PVector getSteeringForce(ArrayList<Boid> boids, PVector mousePosition) {
        PVector steeringForce = new PVector(0, 0);
        
        if (mousePosition != null) {
            steeringForce = seekTarget(mousePosition);
        } else {
            steeringForce = getFlockingForce(boids);
        }
        
        PVector separationForce = getSeparationForce(boids);
        separationForce.mult(1.5f);
        steeringForce.add(separationForce);
        
        return steeringForce;
    }
    
    private PVector getFlockingForce(ArrayList<Boid> boids) {
        PVector alignmentForce = getAlignmentForce(boids);
        PVector cohesionForce = getCohesionForce(boids);
        alignmentForce.mult(1.0f);
        cohesionForce.mult(1.0f);
        
        PVector flockingForce = new PVector();
        flockingForce.add(alignmentForce);
        flockingForce.add(cohesionForce);
        
        return flockingForce;
    }
}

/**
* Generates a random color.
* @return The randomly generated color.
*/
public int generateRandomColor() {
    return color(random(255), random(255), random(255));
}


  public void settings() { size(800, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "ProcessingGame" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
